
像代码清单 2-1 那样，如果将 fgets()和 sscanf()组合使用，就可以避免这个问题。
当然，一旦对 fgets()函数的第 2 个参数赋予超过指定长度的字符串，也是会出问题 的。不过，如果像代码清单 2-1 这样指定了 256 个字符，对于自己使用的程序来说应该 是足够了。
顺便说一下，在 scanf()中通过指定复杂的格式说明符，同样可以避免问题的发生。但 我还是感觉不如使用 fgets()这种方式来得便利。
此外，为了解决这个问题，有人会使用 fflush(stdin);，其实这是个错误的处理方 法。
fflush()是对输出流使用的，它不能用于输入流。标准中并没有定义用于输入流的 fflush()的行为

后者的“指向函数的指针的数组”，像下面这样使用：
int (*func_table[])(double) = {    
func0,  
func1,   
func2,   
func3, };   
┊ func_table[i](0.5);  ←调用func_table[i]的函数，参数为0.5

“指向函数的指针”本质上也是指针（地址），所以可以将它赋给指针型变量。
比如有下面的函数原型：
int func(double d);
保存指向此函数的指针的变量的声明如下：
int (*func_p)(double);
然后写成下面这样，就可以通过 func_p 调用 func，
int (*func_p)(double);   ←声明
func_p = func;   ←将func 赋给func_p
func_p(0.5);   ←此时，func_p 等同于func


不只是 gets()，还有比如对于 scanf()这个函数，如果使用"%s"也会招致同样的结 果。但是，你可以通过对 scanf()指定"%10s"来限制字符串的最大长度。

assert()是在 assert.h 中定义的宏，使用方式如下： assert(条件表达式);
若条件表达式的结果为真，什么也不会发生；若为假，则会输出相关信息并且强制终 止程序。